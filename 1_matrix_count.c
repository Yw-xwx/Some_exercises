/*
    两个矩阵相乘,A[P][Q]*B[Q][R];
    所需要的乘法次数是P*Q*R;
    对于多个矩阵相乘,由于矩阵相乘存在结合律,选择不同的运算次序将对总的乘法次数产生影响
    因此对于给定的n个矩阵A1-An,以及每个矩阵的行数和列数.
    计算从第from个矩阵到第to个矩阵相乘所需的最少的总乘法次数.
    
    例如给定6个矩阵的行数和列数,计算从第2个矩阵一直乘到第5个矩阵所需的最少总乘法运算次数(即A2*A3*A4*A5)
    !!!!最优子结构性质:大问题的最优解包含了小问题的最优解.
        即当n个矩阵相乘的总乘法次数P(N)最少时,k个矩阵相乘的总乘法次数P(K)肯定也是最少的,
        因为如果k个矩阵相乘存在更少的乘法次数(即存在t使得t<P(K)),那么用这种运算次序去计算n个矩阵相乘得出的总乘法次数肯定更少(即t+P(N-K) < P(K))
        而这与P(N)最小相矛盾,因此P(N)最小时,P(K)肯定也最小.
    所以反过来,只要保证每次的P(K)都最小,那么P(N)肯定就是最小的.

    算法设计:
    依次从1个矩阵相乘,到2个矩阵相乘,遍历到n个矩阵相乘;
    一个矩阵无需乘,0次乘法;
    2个矩阵直接乘,pqr次乘法;
    3个矩阵开始,会有不同的拆分方式----A1*(A2*A3),(A1*A2)*A3遍历去比较这2个拆分方式下对应的总乘法次数去找最小值;
    而n个矩阵相乘,会有n-1种拆分方式,遍历去比较这n-1个拆分方式下对应的总乘法次数去找最小值;
    满足了前面的P(3),P(4)在各自3、4个矩阵相乘的情况下的总乘法次数最小,于是肯定n个的也是最小.
*/

#include <stdio.h>

int main()
{
    int n;
    scanf("%d", &n);
    int row[n + 1], column[n+1];//下标从1开始,row[i]表示第i个矩阵的行数
    for (int i = 1; i <= n; i++)
        scanf("%d %d", row + i, column + i);
    int from, to;
    scanf("%d %d", &from, &to);
    int m[n+1][n+1]; // m[1][n]=A1*...*An,m[i][j]表示从第i个矩阵乘到第j个矩阵
    for (int i = 1; i <= n; i++)
        for (int j = 1; j <= n; j++)
            m[i][j] = 0;
    //--------------------------------
    for (int i = 1; i <= n; i++)
        m[i][i] = 0;//单独一个矩阵,无需相乘,乘法运算次数为0
    for (int len = 2; len <= n; len++)
    {
        for (int i = 1; i <= n - len + 1; i++) //len=2,m[n-1][n],i-max=n-1 
        {
            int j = i + len - 1;//len=2,m[i][i+1]
            m[i][j] = m[i][i] + m[i + 1][j] + row[i] * row[i + 1] * column[j];
            //从Ai-Aj一共j-i+1个矩阵相乘,默认拆分成第一个矩阵乘以后面j-i个矩阵的乘积,计算相乘的次数
            for (int k = i + 1; k < j; k++)//针对其他可能存在的拆分方式,依次比较
            {
                int cost = m[i][k] + m[k+1][j] + row[i] * row[k+1] * column[j];
                if (cost < m[i][j])
                    m[i][j] = cost;
            }
        }
        // for (int i = 1; i <= n; i++)
        // {
        //     for (int j = 1; j <= n; j++)
        //         printf("%d ",m[i][j]);
        //     printf("\n");
        // }
    }
    printf("%d", m[from][to]);
    return 0;
}